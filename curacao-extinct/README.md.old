# servlet-closure

"All your Servlets are belong to us."

An open-source toolkit for building REST/HTTP-based integration layers on top of Java and asynchronous Servlet's (Servlet 3.0). This library is entirely asynchronous, thread-based, fast, lightweight, modular and testable. It's a great way to connect your Java web-applications to the world without "bloated" frameworks.

This library manages an internal fixed thread pool to handle Servlet requests asynchronously.  It also starts and completes an asynchronous request context automatically, and provides a cleaner pattern to help you write reasonable Servlet controllers.

It is not intended to act as a replacement for complete web-application frameworks &mdash; it doesn't do routing, raw request processing (like parsing a `POST` request body), etc.  In short, it is not a formal web-application *framework* although you can certainly extend the concepts herein to implement something much more robust.

This library is well suited to help you build RESTful web-services backed by an asynchronous capable Servlet container.

Written in Java 7, but can be cross compiled against Java 6 if desired.

## Latest Version

The latest stable version of this library is <a href="http://markkolich.github.com/repo/com/kolich/servlet-closure/1.6.1">1.6.1</a>.

## Resolvers

If you wish to use this artifact, you can easily add it to your existing Maven or SBT project using <a href="https://github.com/markkolich/markkolich.github.com#marks-maven2-repository">my GitHub hosted Maven2 repository</a>.

### SBT

```scala
resolvers += "Kolich repo" at "http://markkolich.github.com/repo"

val servletClosure = "com.kolich" % "servlet-closure" % "1.6.1" % "compile"
```

### Maven

```xml
<repository>
  <id>Kolichrepo</id>
  <name>Kolich repo</name>
  <url>http://markkolich.github.com/repo/</url>
  <layout>default</layout>
</repository>

<dependency>
  <groupId>com.kolich</groupId>
  <artifactId>servlet-closure</artifactId>
  <version>1.6.1</version>
  <scope>compile</scope>
</dependency>
```

## Introduction

If you've written web-applications around raw Servlet's before, you're probably familiar with the usual dance: define a Servlet in your `web.xml`, implement a class that extends `HttpServlet`, and then fill in the corresponding `doTrace`, `doHead`, `doGet`, `doPost`, `doPut`, and `doDelete` methods.

The asynchronous Servlet dance is smiliar &mdash; you still need a set of `doGet`, `doPost`, etc. handler methods in your `HttpServlet` class.  But, in the common asynchronous Servlet implementation, your handler methods will take the incoming `HttpServletRequest` and `HttpServletResponse`, start an asynchronous `AsyncContext` around them, and submit the resulting `AsyncContext` to a thread pool.  From there, a separate thread is responsible for consuming the `AsyncContext`, doing work, and streaming a response back to the client via the enclosed `HttpServletResponse`.

Most asynchronous Servlet implementations look something like this:

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public final class FoobarAsyncServlet extends HttpServlet {

  private final ExecutorService pool_;
  
  public FoobarAsyncServlet() {
    pool_ = Executors.newFixedThreadPool(10); // Thread pool
  }
  
  @Override
  public void doGet(final HttpServletRequest request,
    final HttpServletResponse response) {
    // Start an asynchronous context around the incoming Servlet request/response.
    final AsyncContext context = request.startAsync(request, response);
    // Submit the asynchronous context to a thread pool.
    pool_.submit(new Runnable() {
      @Override
      public void run() {
        try {
          // Do stuff.
        } catch (Exception e) {
          // Handle an error case, perhaps render out an "error response".
        } finally {
          context.complete(); // Important, and required.
        }
      }
    });
    // At this point, the Servlet container request thread that got
    // you here is done, and freed to do addtional work, it is freed
    // to handle additional requests.
  }

}
```

Although verbose, this asynchronous model has a number of advantages.  Most notably that it frees the "request threads" (as managed by the Servlet container) to handle additional requests, while your application core does the real work "elsewhere".

## Why?

Instead of repeating the same `AsyncContext` and thread pool boilerplate in every `HttpServlet`, I figured there has to be a better way.  Sure, you can certainly use frameworks to handle this somewhat complex asynchronous request lifecycle.  Namely, <a href="http://www.springsource.org/spring-framework">Spring</a>.  But as wonderful as it is, Spring is beefy and sometimes you just want something lighter.

I wanted something minimal that performs well given a very large number of concurrent requests, and so I built this library.  Although not as "complete" as frameworks like Spring, this wrapper library is minimal, and very lightweight &mdash; it's enough to at least guide your Servlet implementation down a cleaner and "more performant" path without all of the repeated boilerplate.

## Usage

### Entities

This library uses entities, or types, that know how to write themselves out to an `OutputStream`.  A class that implements the `ServletClosureEntity` interface represents a type that you can `return` from your Servlet controller methods.

Any return type you expect to send back to a client should implement the `ServletClosureEntity` interface:

```java
import com.kolich.servlet.entities.ServletClosureEntity;

public final class MyEntity implements ServletClosureEntity {

  private final String response_;

  public MyEntity(final String response) {
    response_ = response;
  }

  @Override
  public int getStatus() {
    return 200; // 200 OK
  }
  
  @Override
  public String getContentType() {
    return "text/plain";
  }
  
  @Override
  public void write(final OutputStream os) throws Exception {
    os.write(response_.getBytes("UTF-8"));
  }
  
}
```

This is a very primitive example entity &mdash; it simply returns a `200 OK` with a `UTF-8` encoded `String` as the response body.

Per the `ServletClosureEntity` definition, any class that implements the `ServletClosureEntity` interface knows how to do the following things:

* Return an HTTP status code.
* Return its formal MIME `Content-Type`.  Or, return `null` if the type has no associated `Content-Type`.
* Write itself out to an `OutputStream`.

Many useful abstract classes are pre-packaged with this library that implement the `ServletClosureEntity` interface, which you can either directly consume or use to build more complex response entities.  You can find them in the <a href="https://github.com/markkolich/servlet-closure/tree/master/src/main/java/com/kolich/servlet/entities">com.kolich.servlet.entities</a> package.

Note that your Servlet controller methods are *not* required to return a `ServletClosureEntity` compatible type &mdash; perhaps your Servlet controller will render a response directly to the Servlet's response `OutputStream`, in which case your controller method will return `null` indicating that it has already handled the response.

### Handlers

Handlers are the classes that this library calls to do work, asynchronously on a separate thread.  They are most often anonymous inline classes (what we call a "closure") as shown below in the examples.  However, your handler implementations certainly do not have to be anonymous classes &mdash; you can separate handlers, for different HTTP request methods, in entirely separate classes which ultimately makes your Servlet logic cleaner and more maintainable.

Regardless of the implementation strategy, any handler must extend `AbstractServletClosureHandler<T extends ServletClosureEntity>`:

```java
import com.kolich.servlet.handlers.AbstractServletClosureHandler;
import com.kolich.servlet.exceptions.ServletClosureException;

public final class MyHandler
  extends AbstractServletClosureHandler<MyEntity> {
  
  public MyHandler(final Logger logger,
    final AsyncContext context) {
    super(logger, context);
  }

  @Override
  public final MyEntity handle() throws Exception {
    try {
      // Do work.
      return new MyEntity("foobar!");
    } catch (MyCustomException e) {
      throw new ServletClosureException.WithStatus(403, e);
    }
  }

}
```

All handlers must implement a single `handle` method which returns a type `T extends ServletClosureEntity` &mdash; that is, any type `T` that implements the `ServletClosureEntity` interface.  The `handle` method will be called by this library asynchronously when a request is received and ready to be processed.

Note, the `handle` method definition allows you to throw any `Exception` you'd like &mdash; any thrown `Exception` will be caught and handled gracefully by the parent class, `AbstractServletClosureHandler`, to produce a reasonable response.  If you wish to handle and respond to your own `Exception`'s with a custom body or HTTP status code, simply wrap your `handle` method body with a vanilla `try` & `catch` and re-throw your custom `Exception` as a `ServletClosureException.WithStatus` as shown above.

### Your Servlet

#### web.xml

First, define an asynchronous `<servlet>` with its corresponding `<servlet-mapping>` in your `web.xml`:

```xml
<servlet>
  <servlet-name>YourServlet</servlet-name>
  <servlet-class>com.foobar.servlets.YourServlet</servlet-class>
  <load-on-startup>1</load-on-startup>
  <async-supported>true</async-supported>
</servlet>

<servlet-mapping>
  <servlet-name>YourServlet</servlet-name>
  <url-pattern>/api/*</url-pattern>
</servlet-mapping>
```

Note `<async-supported>` should be `true`, which is required to tell the Servlet container this Servlet instance is asynchronous capable.

#### Servlet Implementation

Now, define a class and make sure it extends `AbstractServletClosure`.  This is your Servlet.

Extending `AbstractServletClosure` immediately makes your Servlet asynchronous capable:

```java
import static org.slf4j.LoggerFactory.getLogger;

import com.kolich.servlet.closures.AbstractServletClosure;
import com.kolich.servlet.util.AsyncServletThreadPoolFactory;

public final class YourServlet extends AbstractServletClosure {

  private static final Logger logger__ = getLogger(YourServlet.class); // Slf4j

  private static final int THREAD_POOL_SIZE = 100;
  private static final long ASYNC_TIMEOUT_MS = 0L;
  
  private static final ExecutorService threadPool__ =
    new AsyncServletThreadPoolFactory(THREAD_POOL_SIZE).build();

  public YourServlet() {
    super(threadPool__, ASYNC_TIMEOUT_MS);
  }
  
  // GET
  @Override
  public MyHandler get(final AsyncContext context) {
    return new MyHandler(logger__, context);
  }
  
  // POST
  @Override
  public <T extends ServletClosureEntity> AbstractServletClosureHandler
    <? extends ServletClosureEntity> post(final AsyncContext context) {
    return new AbstractServletClosureHandler<T>(logger__, context) {
      @Override
      public T handle() throws Exception {
        // Do work, and then set the HTTP status code to
        // 204 No Content.
        response_.setStatus(204);
        // Return null to tell the Servlet closure we've handled
        // the response ourselves.
        return null;
      }
    };
  }

}
```

The example Servlet above handles incoming `GET` and `POST` requests because we've defined `get` and `post` methods in our implementation &mdash; any other incoming request, like a `PUT` or a `HEAD`, are immeaditely rejected with a `405 Method Not Supported` by default.

Using this library, the following HTTP request methods are supported:

* HEAD &mdash; `@Override` and implement a `head` method
* GET &mdash; `@Override` and implement a `get` method
* POST &mdash; `@Override` and implement a `post` method
* PUT &mdash; `@Override` and implement a `put` method
* DELETE &mdash; `@Override` and implement a `delete` method
* TRACE &mdash; `@Override` and implement a `trace` method

Note the `get` and `post` method implementations above are quite different.  In the `get` case, we're simply returning a new handler instance that does nothing other than render a simple `UTF-8` encoded `String`.  In the latter case, the `post` method implementation "handles the response" itself &mdash; it sets a the resulting HTTP status code to `204 No Content` and returns `null` indicating that it does not need this library to attempt to render a response.

Per the definition of `AbstractServletClosure` your implementation needs to pass an `ExecutorService` to it via your constructor &mdash; this is *the* thread pool.  We're creating a new `ExecutorService` using the `AsyncServletThreadPoolFactory` utility class provided by this library.  Note that this example demonstrates a single thread pool per Servlet, but in the real world you'll probably want a single thread pool shared by all of your Servlet's.  In that case, you'll need to statically instantiate a shared `ExecutorService` and use it across all of your Servlet implementations.

The size of the underlying thread pool is defined above by the static `THREAD_POOL_SIZE` &mdash; in the real world you'll probably want to pull this out of a configuration file so it's tunable to your environment.  Also, the asynchronous timeout of each `AsyncContext` handled by this Servlet is defined above by the static `ASYNC_TIMEOUT_MS` &mdash; in the real world you'll probably want to pull this out of a configuration file so it's tunable to your environment.

#### AsyncListener Support

In some Servlet's, you may want to define your own `AsyncListener` &mdash; a listener that will be notified in the event that an asynchronous operation initiated on a `ServletRequest` to which the listener had been added has completed, timed out, or resulted in an error.  You can read more about implementing an `AsyncListener` <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/AsyncListener.html">here in the Java EE API</a>.

When implementing a Servlet that extends `AbstractServletClosure`, you can easily define your own `AsyncListener` that will be attached to each `AsyncContext` initiated by this library by overriding and implementing your own `getAsyncListener` method:

```java
import javax.servlet.AsyncListener;

import com.kolich.servlet.closures.AbstractServletClosure;

public final class AnotherServlet extends AbstractServletClosure {

  // ... other stuff here.

  @Override
  public final AsyncListener getAsyncListener() {
    return new AsyncListener() {
      @Override
      public void onComplete(final AsyncEvent e) throws IOException {
        // Do stuff.
      }
      @Override
      public void onError(final AsyncEvent e) throws IOException {
        // Do stuff.
      }
      @Override
      public void onStartAsync(final AsyncEvent e) throws IOException {
        // Do stuff.
      }
      @Override
      public void onTimeout(final AsyncEvent e) throws IOException {
        // Do stuff.
      }
    };
  }

}
```

On receipt of an incoming request, this library will call your Servlet's `getAsyncListener` method and attach the resulting `AsyncListener` to the freshly initiated `AsyncContext`.  This provides access into the various states of the asynchronous request life cycle from within your Servlet.

If you do not need (or want) to attach an `AsyncListener` to `AsyncContext`'s you can either:

1. Implement a `getAsyncListener` method and return `null` to tell this library no `AsyncListener` should be attached to your `AsyncContext`'s.
2. Do not explicitly override and implement a `getAsyncListener` method, in which case the parent class `AbstractServletClosure` will by default attach no `AsyncListener` to your `AsyncContext`'s.  

#### GSON Support

This library has out-of-the-box support for <a href="http://code.google.com/p/google-gson/">Google's GSON toolkit</a>, allowing you to easily render JSON responses from your Servlet implementations.

Any entity you wish to return as JSON to a client using GSON, should extend the `GsonAppendableServletClosureEntity` abstract class:

```java
import com.kolich.servlet.entities.gson.GsonAppendableServletClosureEntity;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import com.google.gson.annotations.SerializedName;

public final class MyGsonEntity extends GsonAppendableServletClosureEntity {

  @SerializedName("foo")
  private final String foo_;
  
  @SerializedName("bar")
  private final int bar_;
  
  public class MyJsonEntity(final String foo, final int bar) {
    super(new GsonBuilder().serializeNulls().create());
    foo_ = foo;
    bar_ = bar;
  }

}
```

In this example, the class `MyGsonEntity` above extends the provided `GsonAppendableServletClosureEntity` abstract class.  When this entity is returned by a consuming `AbstractServletClosureHandler`, the JSON representation of the entity will be rendered to the client as marshalled by GSON.  Additionally, the `Content-Type` and HTTP status code are set automatically for you. 

A instance of `MyGsonEntity` above that looks like this...

```java
final MyGsonEntity gsonEntity = new MyGsonEntity("dog", 2);
```

...would produce the following response if returned from a `AbstractServletClosureHandler`:

```text
HTTP/1.1 200 OK
Content-Type: application/json;charset=utf-8

{"foo":"dog","bar":2}
```

Extending this example to support other custom marshalling techniques (e.g., for XML) is left as an exercise for the reader.

## Bootstrap

This Java library and its dependencies are built and managed using <a href="https://github.com/harrah/xsbt">SBT</a>.

To clone and build servlet-closure, you must have <a href="http://www.scala-sbt.org/release/docs/Getting-Started/Setup">SBT installed and configured on your computer</a>.

The servlet-closure SBT <a href="https://github.com/markkolich/servlet-closure/blob/master/project/Build.scala">Build.scala</a> file is highly customized to build and package this Java artifact.  It's written to manage all dependencies and versioning.

To build, clone the repository.

    #~> git clone git://github.com/markkolich/servlet-closure.git

Run SBT from within servlet-closure.

    #~> cd servlet-closure
    #~/servlet-closure> sbt
    ...
    servlet-closure:1.6.1>

You will see a `servlet-closure` SBT prompt once all dependencies are resolved and the project is loaded.

In SBT, run `package` to compile and package the JAR.

    servlet-closure:1.6.1> package
    [info] Compiling 12 Java sources to ~/servlet-closure/target/classes...
    [info] Packaging ~/servlet-closure/dist/servlet-closure-1.6.1.jar ...
    [info] Done packaging.
    [success] Total time: 4 s, completed

Note the resulting JAR is placed into the **servlet-closure/dist** directory.

To create an Eclipse Java project for servlet-closure, run `eclipse` in SBT.

    servlet-closure:1.6.1> eclipse
    ...
    [info] Successfully created Eclipse project files for project(s):
    [info] servlet-closure

You'll now have a real Eclipse **.project** file worthy of an Eclipse import.

Note your new **.classpath** file as well &mdash; all source JAR's are fetched and injected into the Eclipse project automatically.

## Licensing

Copyright (c) 2015 <a href="http://mark.koli.ch">Mark S. Kolich</a>

All code in this artifact is freely available for use and redistribution under the <a href="http://opensource.org/comment/991">MIT License</a>.

See <a href="https://github.com/markkolich/servlet-closure/blob/master/LICENSE">LICENSE</a> for details.
